let recursive = \self ->
    (\a -> self (\b -> (a a) b))
    (\a -> self (\b -> (a a) b))

let :> = \a -> \b -> :! (:< a b)
let :<= = \a -> \b -> or (:< a b) (:= a b)
let :>= = \a -> \b -> or (:> a b) (:= a b)

let true = 1
let false = 0
let _ = nil

let pair = \first -> \second -> \consumer -> consumer first second

let head = \pair -> pair (\head -> \tail -> head)
let tail = \pair -> pair (\head -> \tail -> tail)

let map = recursive (\self ->
    \transform -> \sequence ->
        if := (tail sequence) nil
        then pair (transform (head sequence)) nil
        else pair
            (transform (head sequence))
            (self transform (tail sequence))
)

let fold = recursive (\self ->
    \accumulate -> \output -> \sequence ->
        if := (tail sequence) nil
        then accumulate output (head sequence)
        else self (accumulate) (accumulate output (head sequence)) (tail sequence)
)

let sum = fold (\output -> \x -> :+ output x) 0

let length = fold (\output -> \x -> :+ output 1) 0

let filter = recursive (\self ->
    \predicate -> \sequence ->
        if := (tail sequence) nil
        then pair (head sequence) nil
        else
            if predicate (head sequence)
            then pair (head sequence) (self predicate (tail sequence))
            else self predicate (tail sequence)
)

let range = recursive (\self ->
    \start -> \end ->
        if :> start end
        then nil
        else pair start (self (:+ start 1) end)
)

let rangeInclusive = \start -> \end ->
    range start (:+ end 1)

let reverse = fold
    (\reversed -> \x -> pair x reversed)
    nil
